# 3. Типы объявления переменных
```
func() for 1..10;

sub func {
	XXX $var;
	$var++;
	say "A=$var";
}
```
XXX = my выдаст 10 единиц (т.к. изначальное значение будет undef, что равносильно 0 в операции инкремента)

XXX = our выдаст числа от 1 до 10, т.к. область видимости $var будет глобальной

XXX = local выдаст ошибку, т.к. local не создаёт переменную, а лишь локализует её в пределах func. Чтобы программа работала корректно, её можно переписать так:
```
func() for 1..10;

our $var = 10;

sub func {
	local $var = 1;
	$var++;
	say "A=$var";
}
```
Результатом выполнения будет 10 двоек, т.к. до инкремента $var имеет значение 1 внутри функции. При этом вне func зеачение $var остаётся равным 10. Объявление local обычно применяют, когда надо в конкретном лексическом контексте изменить значение глобальной переменной, чтобы быть уверенным в том, что вне этого контекста её значение сохраняется и не зааффектит другие места кода. Например, если мы хотим поменять переменную $/ (разделитель при чтении файлов), которая по умолчанию имеет значение символа перевода строки, но так, чтобы не поломать работу с файлами в остальных случаях.

ХХХ = state в данном случае выдаст то же, что и our. Более интересным этот пример можно сделать так:
```
func() for 1..10;

sub func {
	state $var = 10;
	$var++;
	say "A=$var";
}
```
В данном случае будет последовательность (11, 12, 13, ..., 20), т.к. в отличие от my, переменные, обявленный как state, не реинициализируются в рамках своего лексического контекста при повторном вызове, однако их область видимости - такая же, как если бы они были объявлены как my, т.е. вне своего блока они не видны.
```
sub func {
	my $var if 0;
	$var++;
	say "A=$var";
}
```
Начиная с версии 5.30 в Перле запрещено использовать my() в false контексте. Потому что это плохой паттерн. Например код:
```
{
	my $foo = GetContent('foo.txt');

	# Some other code
	
	my $var = 'baz' if $foo eq 'bar';
	say $var;
}
```
Допустим, функция GetContent() читает содержимое файла foo.txt, и если там написано 'bar', то код отработает корректно. Но если файл по какой-то причине будет изменён, то программа "упадёт", но не на объявлении $var, как это происходит сейчас, а на вызове say. И если между объявлениями $foo и $var достаточно много другого кода, то отследить, почему возникает ошибка, будет очень трудно. Корректно данный код переписать так:
```
{
	my $foo = GetContent('foo.txt');
	my $var;

	if ( $foo eq 'bar' ) {
		$var = 'baz';
	} else {
		die "foo.txt: Invalid content [ $foo ]";
	}

	say $var;
}
```
Теперь, если в файле foo.txt будет находиться что-то отличное от 'bar', то мы сразу это поймём.

# 4. Обработка данных из БД

# 5. Поправить утечку памяти

# 6. Работа с памятью

# 8. Наследование

В данном конкретном случае будут вызваны фнкции классов DD, BB и AA, т.к. SUPER возвращает только 1-й модуль из списка use parent. Прагма parent - это синтаксический сахар и эквивалент такого кода:
```
BEGIN {
	require BB;
	require CC;

	push @ISA, qw/BB CC/;
}
```
Чтобы получить доступ ко всем функциям func() переисленных в use parent модулей, надо переписать модуль DD следующим образом:
```
package DD;
use parent qw/BB CC/;

sub func {
	print "DD\n";
	map { $ISA[$_]->func(@_) } 0 .. $#ISA;
}
```

