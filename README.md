# 1. Удалить дубли из хеша

p_1.pl

Я считаю, что функция map в Перле реализована максимально оптимально, всегда в аналогичных задачах применяю её. Сколько не приходилось решать подобную этой задачу, любые реализации даже при тех же больших О работали медленнее нативной функции.

# 2. Аксессоры

p_2.pl

Не очень люблю это паттерн. Разве что при условии использования в Moose make_immutable.

# 3. Типы объявления переменных
```
func() for 1..10;

sub func {
	XXX $var;
	$var++;
	say "A=$var";
}
```
XXX = my выдаст 10 единиц (т.к. изначальное значение будет undef, что равносильно 0 в операции инкремента)

XXX = our выдаст числа от 1 до 10, т.к. область видимости $var будет глобальной

XXX = local выдаст ошибку, т.к. local не создаёт переменную, а лишь локализует её в пределах func. Чтобы программа работала корректно, её можно переписать так:
```
func() for 1..10;

our $var = 10;

sub func {
	local $var = 1;
	$var++;
	say "A=$var";
}
```
Результатом выполнения будет 10 двоек, т.к. до инкремента $var имеет значение 1 внутри функции. При этом вне func зеачение $var остаётся равным 10. Объявление local обычно применяют, когда надо в конкретном лексическом контексте изменить значение глобальной переменной, чтобы быть уверенным в том, что вне этого контекста её значение сохраняется и не зааффектит другие места кода. Например, если мы хотим поменять переменную $/ (разделитель при чтении файлов), которая по умолчанию имеет значение символа перевода строки, но так, чтобы не поломать работу с файлами в остальных случаях.

ХХХ = state в данном случае выдаст то же, что и our. Более интересным этот пример можно сделать так:
```
func() for 1..10;

sub func {
	state $var = 10;
	$var++;
	say "A=$var";
}
```
В данном случае будет последовательность (11, 12, 13, ..., 20), т.к. в отличие от my, переменные, обявленный как state, не реинициализируются в рамках своего лексического контекста при повторном вызове, однако их область видимости - такая же, как если бы они были объявлены как my, т.е. вне своего блока они не видны.
```
sub func {
	my $var if 0;
	$var++;
	say "A=$var";
}
```
Начиная с версии 5.30 в Перле запрещено использовать my() в false контексте.
```
{
	my $foo = GetContent('foo.txt');

	# Some other code
	
	my $var = 'baz' if $foo eq 'bar';
	say $var;
}
```
Допустим, функция GetContent() читает содержимое файла foo.txt, и если там написано 'bar', то код отработает корректно. Но если файл по какой-то причине будет изменён, то программа "упадёт", но не на объявлении $var, как это происходит сейчас, а на вызове say. И если между объявлениями $foo и $var достаточно много другого кода, то отследить, почему возникает ошибка, будет очень трудно. Корректно данный код переписать так:
```
{
	my $foo = GetContent('foo.txt');
	my $var;

	if ( $foo eq 'bar' ) {
		$var = 'baz';
	} else {
		die "foo.txt: Invalid content [ $foo ]";
	}

	say $var;
}
```
Теперь, если в файле foo.txt будет находиться что-то отличное от 'bar', то мы сразу это поймём.

# 4. Обработка данных из БД

Не очень понятный вопрос. О какой БД идёт речь? Если это SQL без поддержки курсоров, то что мешает использовать стандартную пагинацию (LIMIT)?
```
my $res = $dbi-do("SELECT id, data FROM myTable ORDER BY id LIMIT ?, ?", $from, $num);
```
Перебирая $from в цикле $from += $num от 0 до "SELECT count(id) FROM myTable";

# 5. Поправить утечку памяти
```
while (1) {
	my $a = {b => {}};
	$a->{b}{a} = $a;
}
```
Поправить утечку памяти тут можно, использовав Scalar::Util::weaken, что бы сделать $а "мягкой":
```
use Scalar::Util qw/weaken/;

while (1) {
	my $a = {b => {}};

	weaken($a);
	$a->{b}{a} = $a;
}

```
Смысл "мягких" ссылок в том, их наличие не влияет на состояния счётчиков ссылок переменных, на которые они ссылаются, что позволит сборщику мусора уничтожить их. Проблема с этим кодом в том, что часто неочевидно, что $a - это "жёсткая" ссылка на анонимный хеш. Если бы он был объявлен, например, как my %h = (a => {b}), а потом создана ссылка на него $a = \\%h - код был бы более поддерживаемым.

# 6. Работа с памятью
```
while (1) {
	my $a = {};
	$a->{func} = sub {
		$a->{cnt}++;
	};
}
```
Поправить утечку памяти здаесь можно, вынеся декларацию $a за пределы блока:
```
my $a = {};

while (1) {
	$a->{func} = sub {
		$a->{cnt}++;
	};
}

undef $a;
```
Здесь не используются "мягкие" сслыки, просто ссылка на анонимный хеш эксплицитно уничтожается, что позволяет сборщику мусора зачистить и сам хеш по выходу из блока.

# 7. HTTP-запрос

p_7_server.pl   - примитивный HTTP-сервер.
p_7_1.pl        - Синхронный запрос.
p_7_2.pl        - Асинхронный запрос.

Запуск сервера:

./p_7_server.pl &

Он должен поднятся на 127.0.0.1:8181.

Сервер "спит" 2 секунды перед тем, как выдать респонз. По умолчанию клиент ждёт - 5 секунд.

Хотелось сделать максимально "руками", но если честно я бы реализовал это на AnyEvent. В крайнем случае - на IO::Async.

# 8. Наследование

В данном конкретном случае будут вызваны фнкции классов DD, BB и AA, т.к. SUPER возвращает только 1-й модуль из списка use parent. Прагма parent - это синтаксический сахар и эквивалент такого кода:
```
BEGIN {
	require BB;
	require CC;

	push @ISA, qw/BB CC/;
}
```
Чтобы получить доступ ко всем функциям func() переисленных в use parent модулей, надо переписать модуль DD следующим образом:
```
package DD;
use parent qw/BB CC/;

sub func {
	print "DD\n";
	map { $ISA[$_]->func(@_) } 0 .. $#ISA;
}
```
# 9. Поиск в массиве.

p_9.pl - пример кода и сравнительный бенчмарк алгоритмов бинарного и линейного поиска.

# Игровой чат.

Я бы предпочёл использовать gRPC, но если уж есть необходимость седлать всё руками - то тогда IO::Async::Stream с UDP-подключением.

# Раздача карт.

p_cards.pl - пример реализации раздачи карт.

